# Campaign

Campaign is a simple tool for creation and management of banner campaigns on your web. It allows you to
create banner campaigns without knowledge of HTML/CSS/JS, A/B test the banners and in combination with REMP Beam
(for providing statistics) display and evaluate performance of your campaigns.

* Admin
  * [Integration with CMS/CRM](#admin-integration-with-cmscrm)
    * [Javascript snippet](#javascript-snippet)
    * [Segment integration](#segment-integration)
  * [Integration with Beam Journal](#admin-integration-with-beam-journal)

## Admin (Laravel)

Campaign Admin serves as a tool for configuration of banners and campaigns. It's the place for UI generation of banners
and definition of how and to whom display Campaigns. 

When the backend is ready, don't forget to create `.env` file (use `.env.example` as boilerplate), install dependencies and run DB migrations:

```bash
# 1. Download PHP dependencies
composer install

# 2. Download JS/HTML dependencies
yarn install

# !. use extra switch if your system doesn't support symlinks (Windows; can be enabled)
yarn install --no-bin-links

# 3. Generate assets
yarn run all-dev // or any other alternative defined within package.json

# 4. Run migrations
php artisan migrate

# 5. Generate app key
php artisan key:generate

# 6. Run seeders (optional)
php artisan db:seed
```

### Dependencies

- PHP ^7.1.3
- MySQL ^5.7.8
- Redis ^3.2

### Admin integration with CMS/CRM

##### Javascript snippet

Include following snippet into the page to process campaigns and display banners. Update `rempConfig` object
as needed.

Note: To automatically track banner events to BEAM Tracker, add also `tracker` property to `rempConfig` object.
See [BEAM README](../Beam/README.md) for details. The two snippets complement each other and can be combined
into one big JS snippet including Campaign and Beam functionality.
              
```javascript
(function(win, doc) {
    function mock(fn) {
        return function() {
            this._.push([fn, arguments])
        }
    }
    function load(url) {
        var script = doc.createElement("script");
        script.type = "text/javascript";
        script.async = true;
        script.src = url;
        doc.getElementsByTagName("head")[0].appendChild(script);
    }
    win.remplib = win.remplib || {};
    var mockFuncs = {
        "campaign": "init",
        "tracker": "init trackEvent trackPageview trackCommerce",
        "iota": "init"
    };

    Object.keys(mockFuncs).forEach(function (key) {
        if (!win.remplib[key]) {
            var fn, i, funcs = mockFuncs[key].split(" ");
            win.remplib[key] = {_: []};

            for (i = 0; i < funcs.length; i++) {
                fn = funcs[i];
                win.remplib[key][fn] = mock(fn);
            }
        }
    });
    // change URL to location of CAMPAIGN remplib.js
    load("http://campaign.remp.press/assets/lib/js/remplib.js");
})(window, document);

var rempConfig = {
    // UUIDv4 based REMP BEAM token of appropriate property
    // (see BEAM Admin -> Properties)
    // required if you're using REMP segments
    token: String,
    
    // optional, identification of logged user
    userId: String,
    
    // optional, flag whether user is currently subscribed to the displayed content 
    userSubscribed: Boolean,
    
    // optional, this is by default generated by remplib.js library and you don't need to override it
    browserId: String,
    
    // optional, controls where cookies (UTM parameters of visit) are stored
    cookieDomain: ".remp.press",

    // required, Campaign specific options
    campaign: {
        // required, URL host of REMP Campaign
        url: "http://campaign.remp.press",
        
        // Additional params that will be appended links within displayed banner
        //
        // Key represents variable name, value should be defined as callback returning string response.
        // Following example will be appended as "&foo=bar&baz=XXX".
        // If the value is not function, remplib validation will throw an error and won't proceed further.
        bannerUrlParams:  {
            "foo": function() { return "bar" },
            "baz": function() { return "XXX" }
        },
        
        variables: {
            // variables replace template placeholders in banners,
            // e.g. {{ email }} -> foo@example.com
            //
            // the callback doesn't pass any parameters, it's required for convenience and just-in-time evaluation
            //
            // missing variable is translated to empty string
            email: {
                value: function() {
                    return "foo@example.com"
                }
            },
        }
    }
    
    // if you want to automatically track banner events to BEAM Tracker,
    // add also rempConfig.tracker property
    //
    // see REMP BEAM README.md
    
};
remplib.campaign.init(rempConfig);
```

##### Segment integration

To determine who to display a campaign to, Campaign is dependent on user segments - effectively lists
of user/browser IDs which should see a banner. You can register as many segment providers as you want,
the only condition is that the providers should work with the same user-base (one user ID has to always
point to the) same user.

The implementation is required to implement [`App\Contracts\SegmentContract`](app/Contracts/SegmentContract.php)
interface.

All registered implementations are hidden behind facade of `SegmentAggregator`. This facade is then used
to display available segments in configuration listings and to evaluate actual members of segments during
campaign runtime.  

If you want to link the Campaign to your own system, these are the methods to implement:

* `provider(): string`: Uniquely identifies segment provider among other segment providers.
This is internally required to namespace segment names in case of same segment name being used in multiple
segment sources.
    ```php
    return "my-provider"; 
    ```
    
* `list(): Collection`: Returns collection of all segments available for this provider. The structure
of response is:
    ```php
    return [
        [
            'name' => String, // user friendly label
            'provider' => String, // should be same as result of provider()
            'code' => String, // machine friendly name, slug
            'group' => [
                'id' => Integer, // ID of segment group
                'name' => String, // user friendly label of group
                'sorting' => Integer // sorting index; lower the number, sooner the group appears in the list 
            ]
        ],
    ];
    ``` 
    
* `users(CampaignSegment $segment): Collection`: Returns list of user IDs belonging to the segment.
  * `$segment`: Instance of `CampaignSegment` holding the reference to *segment* used in a *campaign*.

  The response is than expected to be collection of integers/strings representing user IDs:
  ```php
  return collect([
      String,
      String,
      // ...
  ])
  ```
  
* `checkUser(CampaignSegment $campaignSegment, string $userId): bool`: Checks whether given `userId` belongs
    to the provided `campaignSegment`. This can either be done against external API (if it's prepared for realtime
    usage) or against cached list of user IDs - it's internal to the implementation. If the implementation
    doesn't support user-based segments, return `false`.

* `checkBrowser(CampaignSegment $campaignSegment, string $browserId): bool`: Checks whether given `browserId`
    belongs to the provided `campaignSegment`. This can either be done against external API (if it's prepared for
    realtime usage) or against cached list of browser IDs - it's internal to the implementation. If the implementation
    doesn't support browser-based segments, return `false`.

* `cacheEnabled(): bool`: Flag whether the segments of this provider used in active campaigns should be cached
    by the application or not. If `true`, Campaign will every hour request `users()` for each active Campaign
    and stores the collection of user IDs to the application cache.

* `getProviderData()`: Provider can pass arbitrary data back to the user's browser. This can be leveraged to cache
    browser/user related information without affecting the backend system. This data can be then altered by JS
    in the frontend application (if needed). All provided data is passed back to the server on each `campaign/showtime`
    request - on each banner display attempt.

    *Note: We use this kind of caching to count number of trackable events directly in browser. Segment rules based
    on these events are then evaluated based on the data provided in cache instead of hitting database.
    This method dramatically improved performance of REMP Beam event database (Elasticsearch).* 
* `setProviderData($providerData): void`: Complementary *providerData* method to store back the data provided
    by frontend application in incoming request.

When implemented, create a segment provider providing the instance of your implementation. The provider
should set `\App\Contracts\SegmentAggregator::TAG` to the class so your implementation would get also
registered to the `SegmentAggregator`.

### Admin integration with Beam Journal

Beam Journal API (also known as Segments API) provides API for retrieving information about ongoing campaigns.
Its integration with Campaign tool is optional, but provides ability to see campaign statistics directly in the Campaign admin interface.

Information on how to set up Journal API can be found in the [documentation](../Beam/go/cmd/segments/README.md) or in the REMP installation [guidelines](https://gist.github.com/rootpd/9f771b5a5bbb0b0d9a70321cec710511#beam). 

Once Journal API is running, you can enable its integration by pointing `REMP_SEGMENTS_ADDR` to Journal API URL in `.env` configuration file.

### Schedule

For application to function properly you need to add Laravel's schedule running into your crontab:

```
* * * * * php artisan schedule:run >> storage/logs/schedule.log 2>&1
```

Laravel's scheduler currently includes:

*CacheSegmentJob*:

- Triggered hourly and forced to refresh cache segments.

*AggregateCampaignStats*:

- Triggered every minute, saves statistics about ongoing campaings from Beam Journal (if configured).

### Queue

For application to function properly, you also need to have Laravel's queue worker running as a daemon. Please follow the
official documentation's [guidelines](https://laravel.com/docs/5.4/queues#running-the-queue-worker).

```bash
php artisan queue:work
```

Laravel's queue currently includes

*CacheSegmentJob*: 

- Triggered when campaign is activated. 
- Trigerred when cached data got invalidated and need to be fetched again.

If the data are still valid, job doesn't refresh them.

### API Documentation

Campaign provides a simple API for several tasks described bellow.

All examples use `http://campaign.remp.press` as a base domain. Please change the host to the one you use
before executing the examples.

All examples use `XXX` as a default value for authorization token, please replace it with the
real token API token that can be acquired in the REMP SSO.

All requests should contain (and be compliant) with the follow HTTP headers. 

```
Content-Type: application/json
Accept: application/json
Authorization: Bearer REMP_SSO_API_TOKEN
```

API responses can contain following HTTP codes:

| Value | Description |
| --- | --- |
| 200 OK | Successful response, default value |
| 202 Accepted | Successful response, accepted for processing | 
| 400 Bad Request | Invalid request (missing required parameters) | 
| 403 Forbidden | The authorization failed (provided token was not valid) | 
| 404 Not found | Referenced resource wasn't found | 

If possible, the response includes `application/json` encoded payload with message explaining
the error further.

---

##### POST `/api/banners/BANNER_ID/one-time-display`

Campaign supports one-time display of banners to specific users. Such banner does not need associated campaign to be displayed.
This can be used e.g. as a way of reminding users about required actions (instead of notifying them via email).

When calling this endpoint, please replace `BANNER_ID` in URL with an actual ID of the banner.
Each one-time banner has to specify its expiration date and a user it shows to (targeted either via user ID or via browser ID).

##### *Body:*

```json5
{
  "user_id": "29953", // String; Required (if browser_id is not present); ID of targeted user
  "browser_id": "aaaaaa-bbbb-cccc-dddd-1111111", // String; Required (if user_id is not present); ID of targeted browser
  "expires_at": "2019-12-29T10:05:00" // Date; Required; RFC3339 formatted datetime, specifying when the one-time banner expires (it won't show after the date)
}
```

##### *Examples*:

<details>
<summary>curl</summary>

```shell
curl -X POST \
  http://campaign.remp.press/api/banners/[BANNER_ID]/one-time-display \
  -H 'Accept: application/json' \
  -H 'Authorization: Bearer XXX' \
  -H 'Content-Type: application/json' \
  -d '{
        "user_id": "29953",
        "expires_at": "2019-12-29T10:05:00"
}'
```

</details>

<details>
<summary>raw PHP</summary>

```php
$payload = [
    "user_id" => "29953",
    "expires_at" => "2019-12-29T10:05:00"
];
$jsonPayload = json_encode($payload);
$context = stream_context_create([
        'http' => [
            'method' => 'POST',
            'header' => "Content-Type: type=application/json\r\n"
                . "Accept: application/json\r\n"
                . "Content-Length: " . strlen($jsonPayload) . "\r\n"
                . "Authorization: Bearer XXX",
            'content' => $jsonPayload,
        ]
    ]
);
$bannerId = 1;
$response = file_get_contents("http://campaign.remp.press/api/banners/{$bannerId}/one-time-display", false, $context);
// process response (raw JSON string)
```

</details>


##### *Response:*

Valid response with 202 HTTP code: 
```json5
{
  "status": "ok"
}
```

## Healthcheck

Route `http://campaign.remp.press/health` provides health check for database, Redis, storage and logging.

Returns:

- **200 OK** and JSON with list of services _(with status "OK")_.
- **500 Internal Server Error** and JSON with description of problem. E.g.:

    ```
    {
      "status":"PROBLEM",
      "log":{
        "status":"PROBLEM",
        "message":"Could not write to log file",
        "context": // error or thrown exception...
      //...
    }
    ```

## MaxMind - GeoIP2 Lite

This product includes GeoLite2 data created by MaxMind, available from [http://www.maxmind.com](http://www.maxmind.com).

## Newsletter Banner

This banner type allows you to directly collect newsletter subscribers. It supports various types of communication with
your newsletter backend API.   

In most cases you are going to need your own API proxy, since most newsletter APIs (including REMP CRM) make use of 
private tokens that should not be exposed to client. In case your newsletter API does not require such, you might not 
need a proxy. 

### Setup

All configuration options are set via `.env`, refer to `.env.example` for full list of available options. 

#### `NEWSLETTER_BANNER_API_ENDPOINT`
Put here your API endpoint (direct or your own proxy).

#### `NEWSLETTER_BANNER_USE_XHR`
In most cases you want to use XHR (a.k.a. AJAX) for communication with your API, however in rare cases of legacy 
backends you might need a regular POST or GET form submission.  In such case, banner closes itself after submission 
since it has no way of knowing if operation was successful.

#### `NEWSLETTER_BANNER_REQUEST_METHOD`
Most of the time APIs require POST requests for data submission. However, if you need GET, you can choose it here. 

#### `NEWSLETTER_BANNER_REQUEST_BODY`  
Applicable only if POST request method is used, since GET method does not have a body. Default option is 
`x-www-form-urlencoded`, however depending on your API needs, you can choose traditional `form-data` that creates 
multipart body or `json`. 

#### `NEWSLETTER_BANNER_REQUEST_HEADERS`  
You can add HTTP headers of your liking, however keep in mind that content-type header is overridden by 
`NEWSLETTER_BANNER_REQUEST_BODY` setting. Please make sure you do not put here any internal tokens or keys, since 
this value is exposed to client.

#### `NEWSLETTER_BANNER_PARAMS_TR`  
Use this setting (accepts JSON) to change names of params `email`, `newsletter_id` and `source` to whatever your 
newsletter API implementation consumes â€“ `email` will contain email address of new subscriber, `newsletter_id` is 
identification of newsletter list your what him/her to subscribe to and `source` will contain banner type. 

#### `NEWSLETTER_BANNER_PARAMS_EXTRA` 
If you need to add any params to request, put it to this JSON. Also remember not to put here any internal tokens or keys.

#### `NEWSLETTER_BANNER_RESPONSE_FAILURE`
JSON object for handling response failures. Set `message_param` prop to indicate where failure message is in response 
object. If your API does not fail with proper HTTP code, you need to set `status_param` and 
`status_param_value`. Example:

If you have such response from newsletter API:
```json
{
  "status": "error", 
  "message": "User already exists"
}
```

You need to set in `.env`:
```dotenv
NEWSLETTER_BANNER_RESPONSE_FAILURE='{"status_param":"status","status_param_value":"error","message_param":"message"}'
```

Please note that `message` prop of this object should always be set (even if your API responds with proper HTTP code). 

### API requirements

Newsletter API is required to respond with `application/json` content-type. It is also a good habit if it responds with 
proper HTTP response code, but if it does not, make sure to properly set up `NEWSLETTER_BANNER_RESPONSE_FAILURE` object. 
If not properly set, banner will consider all responses from API as successful. Your API also should respond with 
failure message that can be shown to subscriber.

A response is considered successful if:
- HTTP response code is `2XX`  
- Content-type is `application/json`  
- JSON response data is not matching
    `NEWSLETTER_BANNER_RESPONSE_FAILURE['status_param']==NEWSLETTER_BANNER_RESPONSE_FAILURE['status_param_value']` 

#### Successful  

### Error handling

#### rempXhrError

Custom event `rempXhrError` available if requests are configured with XHR. It is fired on `form` element if XHR error 
is detected. Event contains following extra information in `detail` field: 

| field      | type     | description  |
|------------|----------|--------------|
| `type`     | *String* | `httpResponse` - for http response codes != 2XX <br>`exception` - for general error, e.g. response content type not JSON |
| `message`  | *String* | Error detail |
| `response` | *Object* | `fetch` response object, applicable for `httpResponse` type |

### UTM tracking

Following params are added to every request or links (e.g. T&C): 

- utm_source: `"remp_campaign"` => always same string
- utm_medium: `displayType` => overlay or inline
- utm_campaign: `campaignUuid` => campaign id
- utm_content: `uuid` => banner id
- banner_variant: `variantUuid` => banner variant id (in campaign)

If you set these params in `NEWSLETTER_BANNER_PARAMS_EXTRA` settings as well, both are included in signup form. Further 
behaviour depends on newsletter API implementation. It is strongly discouraged however. 
